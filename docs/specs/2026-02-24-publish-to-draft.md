# Feature Specification: Publish to Draft + Editor Review

**Author**: James Eastham
**Date**: 2026-02-24
**Status**: Draft
**Last Updated**: 2026-02-24

---

## Executive Summary

This spec covers two related features that complete the content pipeline:

1. **Editor Review** — immediately after a blog post is generated, a second LLM pass acts as
   an editor and produces structured feedback on spelling/grammar, sloppy thinking, and signs
   of AI-generated phrasing. The feedback is stored separately from the post body and shown in
   the review UI. It never appears in the published output.

2. **Send to Draft** — once a piece is approved, a single click pushes it to its destination:
   a GitHub file (with `draft: true` in Astro frontmatter) for blog posts, or a Publer draft
   for social posts. Nothing is auto-published or auto-scheduled. The user retains full control.

---

## Problem Statement

### The Problem

The content generation pipeline ends at "Approved." After approving a piece the user must:

1. **Blog**: manually create a `.md` file, write the Astro frontmatter (title, description,
   pubDatetime, tags), paste the body, commit and push to the blog GitHub repo.
2. **Social**: manually open Publer, create a new post, paste the text, choose platforms,
   configure scheduling.

This friction breaks the habit loop. The harder it is to get content out, the less often
content gets generated — which is the wrong incentive.

### Evidence

- The current `ExportPiece` endpoint produces bare markdown with no frontmatter
  (`# {title}\n\n{body}`). There is no automated path to either platform.
- The Astro frontmatter schema requires four fields (`author`, `title`, `pubDatetime`,
  `description`, `tags`) that are either missing or not generated by the LLM today.

### Current State

Manual copy-paste from the content review UI to:
- A local text editor → git commit → git push (blog)
- Publer web UI → create post → paste text → choose platforms (social)

### Impact of Not Solving

The "Generate → Review → Approve" pipeline produces drafts that cost effort to publish.
Without a clear exit path, approved content sits in the app and the motivation to generate
more content (and therefore add more notes) stalls.

---

## Users

### Primary Persona: James

| Attribute | Description |
|-----------|-------------|
| Role | Solo developer / technical blogger |
| Technical Level | Expert |
| Goals | Consistently publish blog posts and social content without starting from blank page |
| Frustrations | The last mile is manual; approved content sits idle |
| Context | Reviews content from the web UI on desktop; publishes from the same machine |

### Secondary Users

None — this is a single-user self-hosted system.

---

## Success Metrics

### Primary Metric

| Metric | Current | Target |
|--------|---------|--------|
| Time from "Approved" to content live in destination | ~10 min (manual) | ~30 seconds (one click) |

### Guardrail Metrics

- Content must **never** be auto-published or auto-scheduled. Draft state is always the exit
  point from this system.
- Sending to draft must be **idempotent**: clicking the button twice doesn't create two
  Publer drafts or two GitHub files.

### Validation Approach

Manual self-assessment: does the blog post appear in the GitHub repo with `draft: true`?
Does the Publer draft contain the correct text? This is a solo tool with no A/B testing.

---

## Solution

### Overview

**Step 1 — Editor Review (automatic, blog only)**

Immediately after the LLM generates a blog post, a second LLM call acts as an independent
editor. It does not rewrite anything. It produces structured feedback across three categories:

- **Spelling & Grammar** — concrete issues with location context ("paragraph 2: ...")
- **Areas to Expand** — specific claims, sections, or arguments that are thin or unsupported
- **AI Tells** — phrases, patterns, or structural habits that read as LLM-generated
  (e.g., "In conclusion", "It's worth noting that", listicle abuse, overly hedged language)

The feedback is stored in a new `EditorFeedback` field on `ContentPiece`. It is visible in
the review UI as a distinct "Editor Notes" callout below the post body. It is **never
included** in the exported or published output.

**Step 2 — Send to Draft (manual, on approval)**

Add a **"Send to Draft" button** to each approved `ContentPiece` card in the review UI.
The action calls a new backend endpoint that:

- **Blog pieces** → creates a file in the configured GitHub repo at
  `src/content/blog/{date}-{slug}.md` via the GitHub REST API. The file includes the full
  Astro frontmatter with `draft: true`. The blog will not render the post until the user
  removes the `draft: true` flag locally.
- **Social pieces** → creates a Publer draft via `POST /api/v1/posts/schedule` with
  `state: "draft"`. The draft sits in Publer for the user to review, edit, and schedule.

Both integrations are **opt-in via configuration**. If a token is not configured the button
is hidden (or shows a "Configure publishing" prompt).

### Why This Approach

| Decision | Rationale |
|---|---|
| GitHub file with `draft: true` (not a PR) | Less friction than a PR for a solo developer. Astro's native draft mechanism hides the post from the public site until the flag is removed. The user can edit the file in GitHub's web editor or locally before publishing. |
| Publer draft (not scheduled) | Scheduling requires knowing the right time. The user does that in Publer, where they can also customise per platform. Sending as a draft means Publer does the final formatting/scheduling. |
| "Send to Draft" separate from "Approve" | Approval confirms the content is good. Sending to draft is the publishing step. Keeping them separate allows approving multiple pieces and then pushing when ready. |
| Idempotency via `SentToDraftAt` field | Track when a piece was sent. Button becomes disabled and shows a link after first send. Prevents accidental duplicates. |
| Description + tags generated by LLM | These are blog-frontmatter fields. They cannot be derived reliably from the body after the fact. The LLM prompt is extended to produce them during generation, stored on `ContentPiece`. |

### Alternatives Considered

| Alternative | Pros | Cons | Why Not |
|---|---|---|---|
| Create a GitHub PR instead of a direct commit | More review steps | Adds friction for solo dev; PR merge is a third step | Astro's `draft: true` flag is sufficient guard |
| Generate description/tags at send time | No schema change | Two LLM calls; slow UX at a click; latency at the wrong moment | Generate once, store, reuse |
| Push social directly to X/LinkedIn APIs | One step to live | Bypasses Publer; loses scheduling UX; user said always-drafts | User explicitly uses Publer |
| Store Publer account IDs in DB via settings UI | Self-contained | Adds complexity for one-time setup | Config file / env vars is simpler and more secure for secrets |
| Editor LLM rewrites the post | Less work for user | Loses voice; defeats the purpose of voice personalization | Editor annotates only — user decides what to act on |
| Editor runs as background task after generation | Non-blocking | Piece appears before feedback is ready; race condition in UI | Run synchronously in the same pipeline step; generation already has LLM latency |
| Apply editor review to social posts | Consistent | Social posts are short and terse by design; grammar checks add noise | Blog only — social posts don't benefit from the same structural critique |

---

## Data Model Changes

### `ContentPiece` entity — new fields

```csharp
// New fields on ContentPiece entity
public string? Description { get; set; }          // Blog: SEO description (150-200 chars)
public List<string> GeneratedTags { get; set; }   // Blog: frontmatter tags (JSON in DB)
public string? EditorFeedback { get; set; }        // Blog: structured editor notes (markdown)
public DateTime? SentToDraftAt { get; set; }      // Set when "Send to Draft" succeeds
public string? DraftReference { get; set; }        // GitHub file URL or Publer job ID
```

### EF Core migration

New migration: `AddPublishingFieldsToContentPiece`

```sql
ALTER TABLE "ContentPieces"
  ADD COLUMN "Description"     text,
  ADD COLUMN "GeneratedTags"   jsonb NOT NULL DEFAULT '[]',
  ADD COLUMN "EditorFeedback"  text,
  ADD COLUMN "SentToDraftAt"   timestamp with time zone,
  ADD COLUMN "DraftReference"  text;
```

### `ContentPieceResponse` DTO — new fields

```csharp
public record ContentPieceResponse(
    string Id,
    string GenerationId,
    string Medium,
    string? Title,
    string Body,
    string? Description,          // NEW
    List<string> GeneratedTags,   // NEW
    string? EditorFeedback,       // NEW — never sent to GitHub/Publer
    ContentPieceStatus Status,
    int Sequence,
    DateTime CreatedAt,
    DateTime? ApprovedAt,
    DateTime? SentToDraftAt,      // NEW
    string? DraftReference);      // NEW
```

---

## LLM Prompt Changes

### Generation prompt (extended)

Extend the blog post generation to also produce `description` and `tags`:

```
For the blog post, produce a JSON object with these fields:
  - title: string (the post title)
  - description: string (SEO meta description, 1-2 sentences, max 200 characters)
  - tags: string[] (3-5 topic tags, title-case, e.g. [".NET", "AWS Lambda", "Serverless"])
  - body: string (the full markdown body, starting after the frontmatter)

Do not include frontmatter in the body. The body should start with the first paragraph.
```

### Editor prompt (new — blog posts only)

A separate LLM call, made immediately after the blog post is stored. This uses the same
`IChatClient` as generation. The prompt instructs the LLM to act as an editor and annotate,
not rewrite:

```
You are an experienced technical editor. You are reviewing a blog post written by a
developer. Your job is to identify issues — not to rewrite the post.

Produce feedback in exactly this markdown format:

## Spelling & Grammar
[List each issue as a bullet: "Paragraph N: [quote] — [issue]". If none, write "No issues found."]

## Areas to Expand
[List specific claims, sections, or arguments that are thin, unsupported, or would benefit
from a concrete example. Quote the relevant text. If none, write "No issues found."]

## AI Tells
[List phrases, structural habits, or patterns that read as LLM-generated. Examples to watch
for: "In conclusion", "It's worth noting that", "In today's fast-paced world",
over-use of bullet lists, hedging every claim, generic openings, formulaic paragraph
structure. Quote each instance. If none, write "No issues found."]

Do not rewrite any part of the post. Do not give a summary. Do not compliment the post.
Only flag problems.

Here is the blog post to review:

---
{piece.Title}

{piece.Body}
---
```

**Important constraints in the prompt**:
- Explicitly forbids rewriting — the output must be annotations only
- Forbids complimenting the post — editors don't say "great job"
- Quotes the specific text being flagged — actionable, not vague
- Returns structured markdown that maps directly to `EditorFeedback` field

The editor LLM call is made synchronously inside `ContentGenerationService.GenerateContentAsync`
immediately after the blog piece is stored. The result is saved to `piece.EditorFeedback`.
If the editor call fails (API error, timeout), log the error and continue — `EditorFeedback`
remains null and the piece is still usable.

---

## Backend: New Endpoint

### `POST /api/content/pieces/{id}/send-to-draft`

Sends an approved piece to its destination as a draft.

**Request**: no body.

**Response**:

```json
{ "draftReference": "https://github.com/owner/repo/blob/main/src/content/blog/2026-02-24-title.md" }
```

**Error cases**:

| Status | Condition |
|--------|-----------|
| 404 | Piece not found |
| 409 | Piece is not in `Approved` status |
| 409 | Piece has already been sent (`SentToDraftAt` is set) |
| 422 | Publishing not configured (no token for the relevant medium) |
| 502 | GitHub API or Publer API call failed |

**Side effects**:
- Sets `SentToDraftAt = DateTime.UtcNow`
- Sets `DraftReference` to the GitHub file URL or Publer job ID

---

## Backend: Publishing Services

### Interface

```csharp
public interface IPublishingService
{
    bool IsConfigured { get; }
    Task<string> SendToDraftAsync(ContentPiece piece, CancellationToken ct = default);
}
```

### `GitHubPublishingService`

Uses the GitHub REST API to create (or update) a file:

```
PUT https://api.github.com/repos/{owner}/{repo}/contents/{path}
Authorization: Bearer {github_token}
Content-Type: application/json

{
  "message": "draft: {title}",
  "content": "{base64-encoded file content}",
  "branch": "{branch}"        // defaults to "main"
}
```

**File path**: `src/content/blog/{yyyy-MM-dd}-{slug}.md`

**File content** (Astro frontmatter + body):

```markdown
---
author: James Eastham
title: {piece.Title}
pubDatetime: {DateTime.UtcNow:O}
description: {piece.Description}
tags: {piece.GeneratedTags as YAML list}
draft: true
---

{piece.Body}
```

**Idempotency**: if the file already exists (GitHub returns 422 with "sha" required), fetch
the existing file's SHA and send an update request instead of failing.

**Configuration** (`appsettings.json` / environment variables):

```json
{
  "Publishing": {
    "GitHub": {
      "Token": "",           // GitHub Personal Access Token (contents:write scope)
      "Owner": "",           // e.g. "jameseastham"
      "Repo": "",            // e.g. "blog"
      "Branch": "main",      // default: "main"
      "ContentPath": "src/content/blog"  // default Astro blog path
    }
  }
}
```

### `PublerPublishingService`

Creates a Publer draft post:

```
POST https://publer.com/api/v1/posts/schedule
Authorization: Bearer-API {api_key}
Publer-Workspace-Id: {workspace_id}
Content-Type: application/json

{
  "bulk": {
    "state": "draft",
    "posts": [
      {
        "networks": {
          "{platform}": {
            "type": "status",
            "text": "{piece.Body}"
          }
        },
        "accounts": [{ "id": "{account_id}" }]
      }
    ]
  }
}
```

**Async handling**: Publer returns a `job_id`. Poll `GET /api/v1/job_status/{job_id}` up to
10 times (1-second interval) for the result. Store the job_id as `DraftReference` immediately;
update with the final post URL when polling succeeds. If polling times out, the draft was
likely created — log the job_id and return success.

**Account IDs**: configured as a list. Each social piece is sent to all configured accounts.
The user decides which platform(s) to keep in Publer after reviewing the draft.

**Configuration**:

```json
{
  "Publishing": {
    "Publer": {
      "ApiKey": "",
      "WorkspaceId": "",
      "AccountIds": []    // list of Publer account IDs to target
    }
  }
}
```

---

## Frontend Changes

### `PieceCard` — Editor feedback callout (blog only)

When `editorFeedback` is present on a blog piece, render it below the post body as a
distinct callout block — visually separated from the content, never included in export.

```
┌─────────────────────────────────────────────────────┐
│  [FileText]  blog   [Draft]                   2h ago │
│                                                      │
│  Why Your Lambda Is Slow (and How to Fix It)        │
│                                                      │
│  The first paragraph of the blog post               │
│  continues here...                                  │
│                                                      │
│  ── Editor Notes ──────────────────────────────── ▼ │
│  ## Spelling & Grammar                              │
│  No issues found.                                   │
│                                                      │
│  ## Areas to Expand                                  │
│  • "Lambda cold starts are slow" — no data cited.   │
│    Consider adding a benchmark or latency figure.   │
│                                                      │
│  ## AI Tells                                         │
│  • "In conclusion" (final paragraph) — common LLM   │
│    closing pattern. Consider a more direct ending.  │
│  ─────────────────────────────────────────────────  │
│                                                      │
│  [Approve] [Reject] [Regenerate] [Export]           │
└─────────────────────────────────────────────────────┘
```

Implementation notes:
- Rendered in an `amber-50/amber-200` callout box (warning tone — advisory, not blocking)
- Collapsible: defaults to **expanded** so it's not missed. Clicking the header collapses it.
- The editor feedback is **raw markdown** stored in `editorFeedback`. Render it with a
  lightweight markdown renderer (the existing Tiptap setup is overkill here — use `marked`
  or a simple regex-based renderer for the three-section structure)
- The callout label reads "Editor Notes" not "AI Feedback" — keeps the framing human

### `PieceCard` — "Send to Draft" button

After the existing Approve/Reject/Regenerate/Export buttons, add:

```
[Approve]  [Reject]  [Regenerate]  [Export]  [Send to Draft →]
```

- **Visible**: only when `status === 'Approved'` AND `sentToDraftAt === null`
- **Disabled**: while the mutation is pending
- **After success**: button is replaced by a small indicator:
  - Blog: "Sent to GitHub →" (links to `draftReference` file URL)
  - Social: "Sent to Publer ✓"
- **On error**: toast with the error message ("GitHub API error — check your token")

### Settings page — Publishing section

New section in `settings.tsx` showing:

```
Publishing

  Blog (GitHub)      ● Configured  / ○ Not configured
  Social (Publer)    ● Configured  / ○ Not configured
```

Configuration is done via environment variables / appsettings — no secrets are entered via
the UI. The settings page just reads the configured state from a new
`GET /api/settings/publishing` endpoint.

---

## User Stories

### Epic: Send to Draft

#### Story 1: Send approved blog post to GitHub

**As** James
**I want** to push an approved blog post to my GitHub repo with one click
**So that** I can review and publish it without manual copy-paste

**Acceptance Criteria**:
- [ ] Given a piece with `status = Approved` and `medium = blog`, when I click "Send to Draft",
  then a file appears in the configured GitHub repo under `src/content/blog/`
- [ ] The file has the correct Astro frontmatter: `author`, `title`, `pubDatetime` (current
  time), `description`, `tags`, `draft: true`
- [ ] The `body` starts immediately after the frontmatter with no duplication of the title
- [ ] The button shows a "Sent to GitHub" state with a link to the file after success
- [ ] Clicking "Send to Draft" a second time does nothing (idempotent)
- [ ] If the GitHub token is not configured, the button is hidden

#### Story 2: Send approved social post to Publer

**As** James
**I want** to push an approved social post to Publer as a draft
**So that** I can schedule it without copy-pasting

**Acceptance Criteria**:
- [ ] Given a piece with `status = Approved` and `medium = social`, when I click "Send to
  Draft", then a draft appears in Publer
- [ ] The draft contains the `piece.body` text exactly
- [ ] The draft is in `state: draft` — not scheduled, not published
- [ ] The button shows "Sent to Publer" after success
- [ ] Clicking "Send to Draft" a second time does nothing
- [ ] If the Publer API key is not configured, the button is hidden

#### Story 3: Editor review surfaces issues before approval

**As** James
**I want** a second LLM to critique my generated blog post before I approve it
**So that** I can catch grammar issues, thin arguments, and AI-sounding phrasing without
reading the full post with fresh eyes every time

**Acceptance Criteria**:
- [ ] Given a newly generated blog `ContentPiece`, the `editorFeedback` field is populated
  automatically (no user action required)
- [ ] The feedback appears in the review UI below the post body in an amber callout box,
  defaulting to expanded
- [ ] The feedback has three sections: Spelling & Grammar, Areas to Expand, AI Tells
- [ ] Each finding quotes the specific text being flagged (not vague "the post is generic")
- [ ] If there are no issues in a category, the section reads "No issues found."
- [ ] The editor feedback is **not** included in the markdown export
- [ ] The editor feedback is **not** pushed to GitHub or Publer
- [ ] If the editor LLM call fails, the piece is still usable — `editorFeedback` is null and
  no error is surfaced to the user (failure is logged server-side)
- [ ] Editor review only runs for `medium = blog`, not social posts

#### Story 4: LLM generates description and tags for blog posts

**As** James
**I want** the generated blog post to include a description and relevant tags
**So that** the Astro frontmatter is complete without manual editing

**Acceptance Criteria**:
- [ ] A generated blog `ContentPiece` has a non-empty `description` (≤ 200 chars)
- [ ] A generated blog `ContentPiece` has 3-5 items in `generatedTags`
- [ ] The description is a genuine summary of the post, not the first sentence of the body
- [ ] Tags are topic-relevant (e.g. `.NET`, `AWS`, `Serverless`) not generic (e.g. `blog`)

---

## Scope

### In Scope

- **Editor review**: second LLM pass on blog posts immediately after generation
- `EditorFeedback` field on `ContentPiece`, rendered as amber callout in `PieceCard`
- GitHub REST API integration for blog posts (create file, update if exists)
- Publer API integration for social posts (create draft)
- `SentToDraftAt` + `DraftReference` tracking on `ContentPiece`
- `Description` + `GeneratedTags` fields on `ContentPiece` (LLM-generated)
- "Send to Draft" button in `PieceCard` (approved pieces only)
- Publishing configuration status on settings page

### Out of Scope

- Editor review for social posts
- Editor rewriting or auto-correcting the post (annotations only)
- Automatically sending to draft on approval (user must click explicitly)
- Scheduling from within the app (Publer handles scheduling)
- Merging or publishing the GitHub draft (user does this in GitHub or locally)
- Per-platform customisation of social post text (Publer allows editing the draft)
- Analytics on what was published (future)
- Multiple publishing destinations (only one GitHub repo, one Publer workspace)
- Webhook confirmation from Publer that the draft was actually created

### Future Considerations

- "Mark as Published" status + `publishedAt` field, once a piece goes live
- Newsletter medium: push to ConvertKit/Buttondown as a draft email
- QR-code setup in settings for easier Publer account ID discovery
- Inline description/tags editing in the review UI before sending

---

## Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|---|---|---|---|
| Generated content sounds generic | Medium | High | Editor review explicitly flags AI tells. Draft-only approach means user can edit in Publer/GitHub before going live. |
| Editor flags good content as AI-generated | Medium | Low | The editor annotates; it never blocks. The user decides what to act on. A false positive on "AI tells" just gets ignored. |
| Editor feedback is vague ("the post is generic") | Medium | Medium | Prompt explicitly requires quoting the specific text being flagged. Vague feedback is a prompt engineering problem — iterate on the prompt if this occurs. |
| Editor LLM call adds too much latency to generation | Low | Medium | The editor prompt is analysis-only (no generation). Response should be significantly faster than the generation call. Monitor and log editor call duration. |
| LLM produces poor descriptions or wrong tags | Medium | Medium | Visible in review UI before sending. Regenerate if poor quality. Future: allow inline editing. |
| GitHub token with too broad scope | Low | High | Use a fine-grained PAT with `contents:write` on the specific blog repo only, not a classic token. Document this in the setup guide. |
| Publer async job polling times out | Low | Low | Log the `job_id`. The draft was almost certainly created. User can check Publer directly. |
| Duplicate GitHub files (same slug, different runs) | Low | Medium | Fetch existing file's SHA on `GET`, use it on `PUT` to update rather than fail. Identical titles update the same file. |
| `draft: true` removed accidentally before post is ready | Low | Low | Astro requires an explicit file edit to remove it. Intentional action. |

---

## Dependencies

| Dependency | Detail | Blocker? |
|---|---|---|
| Editor LLM call | Second `IChatClient` call in `ContentGenerationService` after blog piece is stored | Yes |
| GitHub REST API | `contents` endpoint — create/update file | Yes |
| Publer API | `POST /api/v1/posts/schedule` with `state: draft` | Yes |
| LLM prompt changes | `description` + `tags` fields in blog generation output | Yes |
| EF Core migration | New fields on `ContentPiece` (`EditorFeedback`, `Description`, `GeneratedTags`, `SentToDraftAt`, `DraftReference`) | Yes |
| Publer account IDs | Must be discovered manually from Publer settings | No (config step) |

---

## Open Questions

- [ ] **Should editor feedback be dismissible per-piece?** A "Dismiss" button that clears
  `EditorFeedback` (or sets `EditorFeedbackDismissedAt`) would let the user signal "I've
  read this and I'm happy." Low priority — the callout is collapsible, which is sufficient.
  - This is unneccessary
- [ ] **Should the editor run on regenerated pieces?** Currently specified to run at first
  generation only. If a piece is regenerated (via "Regenerate" button), should the editor
  re-run? Recommendation: yes — the regenerated content is new and should get a fresh review.
  Track this at the service layer: call editor after any blog piece is written.
  - Yes, the editor should always run
- [ ] **Should `description` be editable in the review UI?** Adding an editable field before
  send would catch poor LLM quality without a full regenerate. Adds UI complexity.
  - Yep, let's add the description
- [ ] **Should tags be editable in the review UI?** Same question as description. Low effort
  to add an editable tag list to the approved card.
  - Yes, let's add the editable tags
- [ ] **What if the blog uses a different `src/content/blog` path?** Make `ContentPath`
  configurable (it already is in the proposed config schema).
  - Yes, let's make it configurable but default to src/content/blog
- [ ] **Publer account IDs discovery**: should there be a `GET /api/settings/publishing/publer/accounts`
  endpoint that calls the Publer accounts list API? This would avoid manual ID lookup.
  - Account IDs can be manually added, that's no problem

---

## Technical Notes

### GitHub file path and slug generation

```
slug = SanitizeFilename(piece.Title).ToLowerInvariant()
date = DateTime.UtcNow.ToString("yyyy-MM-dd")
path = $"{ContentPath}/{date}-{slug}.md"
```

Reuse the existing `SanitizeFilename` method from `ContentController`.

### Astro frontmatter template (C# verbatim string)

```csharp
var frontmatter = $"""
    ---
    author: James Eastham
    title: {piece.Title}
    pubDatetime: {DateTime.UtcNow:O}
    description: {piece.Description}
    tags: [{string.Join(", ", piece.GeneratedTags.Select(t => $"\"{t}\""))}]
    draft: true
    ---

    {piece.Body}
    """;
```

### Publer authentication header

Publer uses a non-standard bearer format:

```
Authorization: Bearer-API {api_key}
```

Note the `Bearer-API` prefix (not `Bearer`). This is different from the standard OAuth2
format. An `HttpClient` configured with a custom `Authorization` header is required.

### Configuration binding

Use `IOptions<PublishingOptions>` pattern, consistent with the existing codebase style.
The service is only registered when the relevant config section is populated:

```csharp
if (!string.IsNullOrEmpty(config["Publishing:GitHub:Token"]))
    services.AddSingleton<IGitHubPublishingService, GitHubPublishingService>();
```

This means `IsConfigured` on the interface returns false (and the button is hidden) when
the token is absent — no null-reference errors, no user-facing error states for unconfigured
integrations.
